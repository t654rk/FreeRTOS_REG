Проект является перманентным ковырянием процессов
включения и работы микроконтроллеров stm32f051R8 минуя служебный
soft типа system_stm32f0xx.c, stm32f0xx_rcc.c и проч.

Конечная цель проекта честное измерение действующего напряжения периодических
сигналов произвольной формы одинаковой частоты на четырех входах АЦП.

Собственно, ничего нового, докручена сверху еще и FreeRTOS.
https://www.youtube.com/watch?v=xXGXn9D04nE

Отладочная плата STM32F0DISCOVERY, вернее две платы несколько раз выгорали
в процессе работы с трехфазным двигателем промышленной сети, поэтому на них
были допаяны кварцы, поскольку выводы MCO stm32F103-загрузчика, были повреждены.
Неоднократно перепаивались микроконтроллеры. В конечном счете на одной
из плат был заменен микроконтроллер на stm32L162RE (не для этого проекта).
Достаточно живучая штучка!

Не забываем, что при портировании FreeRTOS добавляется файл portasm.s,
в котором есть #include <FreeRTOSConfig.h>, а в настройках проекта
у ассемблера свой препроцессор.
Сам FreeRTOSConfig.h, признаюсь, я сформировал в CubeMX.

Файлы System_HSE_init.c, System_HSI_init.c, в зависимости от включения в проект,
осуществляют настройки тактирования от HSE и HSI, соответственно.

MCO.c - удалять не стал, в проекте не используется.

Measurements.c - содержит инициализацию TIM14, TIM15, ADC и DMA1_Channel1.

TIM15 используется для измерения периода входного сигнала на пине PA2.
PA3 можно использовать для дальнейшего развития.
Ничего не изобретал. Полностью скопировал пример из RM0091 pg. 951 A.9.4
Input capture data management code example. Единственно предделитель взял
на 2 порядка меньше, чтобы период можно было делить на 24.
Генерация обновления, запуск счета и разрешение прерываний происходит
в задаче vTaskSignal1PeriodMeasuring с умной задержкой 1 секунда.
Очень долго просидел разрешив прерывание по переполнению. Этого делать не нужно!
В обработчике TIM15_IRQHandler период помещается в очередь Signal1PeriodData
и по xBinarySemaphoreTIM15 управление передается псевдообработчику vTaskTIM15_IRQ.
Задача висит в блокировке до появления семафора. При появлении удаляется,
а затем создается счетный семафор xCountingSemaphoreADCSpeedNormal. Последний
не особо нужен, но позволяет делать грубую оценку частоты сигнала в сторону уменьшения.
Если период можно целочисленно разделить на 24, инициализируется TIM14.
Измеренный период ставится в очередь USARTPeriodPrint на вывод.
Обычно в инженерных задачах период измерять не нужно, поскольку датчиками
мы меряем уже что-то понятное, например подаем ШИМ на двигатель с заданной
в другом месте частотой и меряем ток.

TIM14 просто считает от нуля до периода, деленного на 24. 24 - это количество
отрезков на которых измеряем мгновенное значение напряжения. В прерывании
по переполнению запускается ADC & DMA.
Возможно, здесь стоит отметить, что счетчик сначала уходит в прерывание,
а уже только потом начинает считать до следующего прерывания. Нас это полностью
устраивает. Сразу после инициализации запускается ADC & DMA.
В обработчике TIM14_IRQHandler увеличивается значение xCountingSemaphoreADCSpeedNormal
и, если это значение успело быть уменьшено в vTaskDMA1_Channel1_IRQ, запускается ADC.
Достаточно интересная ситуация происходит, если период сигнала меньше количества симплов.
Период делится на их количество и TIM14->ARR становится равным нулю.
В этом случае счетчик считает до 0xffff. Такой ситуации лучше избежать, что мы и делаем.

ADC & DMA подробно закомментированы. На что хотелось бы обратить внимание:
- В stm32f051R8 не корректно работает прерывание по половине буфера.
Экспериментам было уделено достаточное время. Грешил в том числе и на отладчик.
В конце концов поставил в каждом флаге по cr1++; & cr2++; И кто больше, скажем 1000,
останавливаемся. Значения переменных всегда значительно отличались. Где-то читал,
что тоже не удалось решить данную проблему. Этот факт накладывает некоторые ограничения
на данную задачу. Однако в проекте целостность данных при прерывании DMA1->ISR & DMA_ISR_TCIF1
контролируется в псевдообработчике vTaskDMA1_Channel1_IRQ, куда мы уходим
из DMA1_Channel1_IRQHandler по двоичному семафору xBinarySemaphoreDMA1_Channel1.
За отрезок, назовем его симплом, счета TIM14, ADC измеряет амплитудное значение
четырех каналов регулярной группы по 8 раз каждый. Инициализация сторожа закомментирована.
Время выборки взято максимальным, но, чтобы успеть считать частоту 166 Гц.
Это частота двигателя на 100000 оборотах в минуту. Были раньше такие винчестеры.
Шустрее движка я не нашел. Массив ADC1_Simpl [32] я оставил глобальным, поскольку
его обработка критична по времени.

Псевдообработчик прерывания vTaskDMA1_Channel1_IRQ - задача с максимальным приоритетом,
висит в блокировке до появления данных по каналу DMA и выходит из блокировки по семафору
xBinarySemaphoreDMA1_Channel1.
После чего данные накопительно суммируются отдельно по каждому каналу. Затем проверяем
корректность данных значением счетного семафора xCountingSemaphoreADCSpeedNormal,
предварительно уменьшив его на единицу. Если до этой операции не произошло еще одного
прерывания по переполнению TIM14, данные корректны, иначе обрабатываем ошибку.
Логическим сдвигом >> 3 делим данные на 8 и получаем среднее значение на отрезке.
Затем вычитаем позицию нуля датчика. Отрицательные значения АЦП не меряет, поэтому
датчик крутятся вокруг какого-то своего нуля, скажем 2048 (1,65 В). Мой опыт показал,
что эта позиция нуля тоже штука не хорошая, зависит от температуры и проч. Как вариант,
я считал ее статистически какое-то время при включении оборудования.
При измерении среднего значения напряжения, нужно инвертировать знак, если значение
отрицательно. Поскольку у нас впереди интегральная сумма квадратов - это лишнее.
Накапливаем сумму квадратов на 24 отрезков и по счетчику сливаем ее в очередь
Integr_Simpl_Queue для задачи подсчета квадратных корней.
В случае ошибки (xCountingSemaphoreADCSpeedNormal > 0) обнуляем не корректные данные
Увеличиваем семафор, поскольку мы его уменьшали. (Не уменьшать нельзя). И заполняем
очередь FrequencyERRORPrint флагом ошибки и значением семафора. Заодно блокируем
запуск АЦП в прерывании TIM14. Я не до конца понял, почему значение этого семафора
отличается от количества прерываний. Функции записать в счетный семафор ноль - нет.
Возможно операция уменьшения семафора в цикле основной программы и одновременного
увеличения в прерывании не является корректной. В конце концов, мне нет дела до
значения этого семафора после фиксации ошибки данных. Поэтому я его удаляю и вновь
создаю перед инициализацией TIM14 при очередном измерении периода сигнала.

Задача vTaskPeriod_End расчета квадратных корней висит в блокировке до появления
значений в очереди интегральных сумм квадратов значений по четырем каналам.
По приходу значений они целочисленно делятся на количество симплов и попадают
в функцию uint16_t sqrt_GLS (uint32_t x)  // Hordware algorithm [GLS].
Алгоритм функции взят на каком-то радиотехническом форуме без изменений.
Данные нормируются и пытаются угодить в очередь на вывод. Если очередь
USARTRMSPrint не готова их принять в зависимости от vTaskDelay(900),
задачи vTaskUSART1Print, данные усредняются. В зависимости от этой задержки,
можно столбиком вывести несколько измерений и посмотреть разброс, либо вывести
усредненное вплоть до численного значения частоты в Герцах. Иными словами,
если выводить раз в секунду, то берется среднее значение по всем измерениям
за эту секунду, что не плохо смотрится относительно величин, которые показывает
мой осциллограф.
Задача vTaskUSART1Print, как я понял, является задачей привратника
см. http://microsin.net/programming/arm/freertos-part4.html.
В нее сливаются все очереди на вывод в USART и корректно выводятся.
Здесь можно до сыта наиграться с параметром очередей xTicksToWait.
Видно что выводится, как, когда, зачем и почему.
По самому USART тоже особо нечего. Все из видео уроков
https://www.youtube.com/watch?v=xXGXn9D04nE
с той разницей, что в stm32f051R8 USART имеет отдельно регистры данных
на чтение и на запись и кучу всяких интересных флагов прерываний,
которые закомментированы в обработчике

Generator.c & PWM_Tim1.c
Взять генератор, в моем случае, оказалось самым простым его написать.
Цап выводит на пин PA4 синус из файла Sin_DAC_3V.h, рассчитанный в MsExcel
(файл DAC_3xSinTable-24.xls, Output_Value.xlsx).
Событие триггера формируется TIM6. Синус запихивается через DMA1_Channel3.
То есть все, как в мануале. Однако в stm32f051R8 ЦАП всего один, а на одном
пине нужно мерять период, а на других напряжения и не факт, что параллелить их
без дополнительных аппаратных решений есть правильно. Поэтому я запустил
ШИМ на первом таймере, (Pins PB13, PB14, PB15) с той же частотой, что и синус
и разной скважностью.

Результатами измерений я остался доволен. Проект имеет исключительно обучательный
статус и предполагает бесконечную дискуссию.
Хочется добавить: "Не пытайтесь повторить это у себя дома!" Действующее напряжение
измеряется проще, быстрее и точнее без использования FreeRTOC на микроконтроллере
с таким минимумом ресурсов.

Петр Мальцев.
