#include "stm32f051x8.h"
extern const uint16_t MeasuringCountersPrescaler;

//______________________________________________________________________________
void TIM14_Init(uint16_t psc, uint16_t arr)
{
      RCC->APB1ENR |= RCC_APB1ENR_TIM14EN;        // Включить TIM14 по шине APB1ENR

  TIM14->CR1    &= ~TIM_CR1_CEN; // Останавливаем счет
  
  TIM14->CR1 |= TIM_CR1_ARPE;   //Включен режим предварительной записи регистра автоперезагрузки
  
  TIM14->PSC = psc;             // Установка предварительного делителя

  TIM14->ARR = arr;             // Установка границы счета
  
  TIM14->DIER |= TIM_DIER_UIE;  // Разрешить прерывание по переполнению

  TIM14->EGR |= TIM_EGR_UG;     // генерация обновления
  
  TIM14->CR1    |= TIM_CR1_CEN; // Запускаем счет
  
//  NVIC_EnableIRQ(TIM14_IRQn);
  NVIC->ISER[0] = (1 << ((TIM14_IRQn) & 0x1F));     // Разрешить TIM14_IRQn  & 0x1F
}

//______________________________________________________________________________
void TIM15_Init(void)
{
    GPIOA->MODER |= GPIO_MODER_MODER2_1;            // Alternate function mode
    GPIOA->MODER |= GPIO_MODER_MODER3_1;            // Alternate function mode
    
    // TIM15_CH1, TIM15_CH2     AF0 - и так ноль
    GPIOA->AFR[0]   &= ~(0xF << 8);                     // TIM15_CH1
    GPIOA->AFR[0]   &= ~(0xF << 12);                    // TIM15_CH2
    
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;          // Включить тактирование портов
        
    RCC->APB2ENR |= RCC_APB2ENR_TIM15EN;        // Включить TIM15 по шине APB2ENR
    
    // Здесь, если считать за секунду, то должен быть предделитель 48000-1
    // Но нам нужно считать от 1 Гц, до 200 Гц с максимальной точностью
    TIM15->PSC =   MeasuringCountersPrescaler;                      //пред делитель
    TIM15->ARR =   65535 ;                      //считаем до....
    TIM15->CR1 |= TIM_CR1_ARPE;     //Включен режим предварительной записи регистра автоперезагрузки
    
    TIM15->CCMR1 |= TIM_CCMR1_CC1S_0;           // выбираем TI1 для TIM15_CH1
    //TIM15->CCMR1 |= TIM_CCMR1_CC2S_0;
    //TIM15->CCMR1 |= TIM_CCMR1_CC2S_1;
    //  Определяет направление канала (ввод / вывод), а также используемый ввод.
    //  00: канал CC1 настроен как выходной.
    //  01: канал CC1 настроен как вход, IC1 отображается на TI2.       ????? TI1
    //  10: канал CC1 настроен как вход, IC1 отображается на TI1.       ????? TI2
    //  11: канал CC1 настроен как вход, IC1 отображается на TRC. Этот режим работает только в том случае, если вход внутреннего триггера выбран через бит TS (регистр TIMx_SMCR)
    //  Примечание: биты CC1S доступны для записи, только когда канал выключен (CC1E = «0» в TIMx_CCER).
    TIM15->CCMR1 |= TIM_CCMR1_IC1F_0 | TIM_CCMR1_IC1F_1;        //Ждем 8 тиков пока фронт устаканится
    //TIM15->CCMR1 &= ~TIM_CCMR1_IC1F;            // не фильтруем
    TIM15->CCMR1 &= ~TIM_CCMR1_IC1PSC;          // делитель не используем
    
    //TIM15->SMCR |= TIM_SMCR_TS_2 | TIM_SMCR_TS_0 | TIM_SMCR_SMS_2;
    
    //TIM15->CCER &= ~TIM_CCER_CC1P;              //    захват по переднему фронту
    TIM15->CCER |= TIM_CCER_CC1P;              //      захват по заднему фронту
    //TIM15->CCER |= TIM_CCER_CC2P;              //      захват по заднему фронту
    //  Канал CC1 настроен как вход:
    //  Биты CC1NP / CC1P выбирают полярность TI1FP1 и TI2FP1 для операций запуска или захвата.
    //  00: неинвертированный / передний фронт: схема чувствительна к переднему фронту TIxFP1 (захват, триггер в режиме сброса или триггера), TIxFP1 не инвертируется (триггер в стробированном режиме).
    //  01: инвертированный / спадающий фронт: схема чувствительна к спадающему фронту TIxFP1 (захват, триггер в сбросе или режиме триггера), TIxFP1 инвертирован (триггер в стробированном режиме).
    //  10: зарезервировано, не используйте эту конфигурацию.
    //  11: неинвертированный / оба фронта: схема чувствительна как к переднему, так и к заднему фронту TIxFP1 (захват, триггер в режиме сброса или триггера), TIxFP1 не инвертирован (триггер в стробированном режиме).
    //  Примечание: этот бит не доступен для записи, если запрограммирован уровень 2 или 3 LOCK (биты LOCK в регистре TIMx_BDTR).
    
    TIM15->CCER |= TIM_CCER_CC1E;               // Регистр разрешения захвата / сравнения TIM15
    //TIM15->CCER |= TIM_CCER_CC2E;               // Регистр разрешения захвата / сравнения TIM15
    //  Канал CC1 настроен как вход:
    //  Этот бит определяет, может ли фактически быть произведен захват значения счетчика во входной регистр захвата / сравнения 1 (TIMx_CCR1) или нет.
    //  0: захват отключен
    //  1: захват включен
    
    //TIM15->DIER |= TIM_DIER_CC1DE;              // разрешаем формировать запрос к DMA
    TIM15->DIER |= TIM_DIER_CC1IE;              // разрешаем прерывание по захвату
    //TIM15->DIER |= TIM_DIER_CC2IE;              // разрешаем прерывание по захвату
    //TIM15->DIER |= TIM_DIER_UIE;                // разрешаем прерывание по переполнению
    
//    TIM15->CR1 |= TIM_CR1_CEN;                  // включаем счётчик
//    NVIC_EnableIRQ(TIM15_IRQn);                 // включаем прерывание
    

}

//______________________________________________________________________________
void ADC_Init(void)
{
  
  RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
  GPIOC->MODER |= (GPIO_MODER_MODER0 | GPIO_MODER_MODER1 | GPIO_MODER_MODER2 | GPIO_MODER_MODER3) ;
  
  RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;     // Включили тактирование ADC
  RCC->AHBENR |= RCC_AHBENR_DMA1EN;       // Включить периферийные часы на DMA

//______________________________________________________________________________  
  DMA1_Channel1->CCR |= DMA_CCR_MINC | DMA_CCR_MSIZE_1 | DMA_CCR_PSIZE_0;
  // ДМА настраивается вперед АЦП )) Если интересно все настройки в комментарии ниже
//______________________________________________________________________________
  
RCC->CR2 |= RCC_CR2_HSI14ON;                    // Активировать внутренний генератор HSI14 для АЦП
while ((RCC->CR2 & RCC_CR2_HSI14RDY) == 0);      // Дождаться
// RC-генератор HSI 14 МГц не может быть включен с помощью интерфейса АЦП, когда часы APB выбраны как часы ядра АЦП.
// HSI14-генератор (тактирование АЦП). Данный RC-генератор является одним из двух способов тактирования блока АЦП (ADC)
// (второй  способ – через тактовую частоту PCLK, делённую на 2 или 4)

// Выключение. В мануале рекомендуют выключать прежде чем включать на всякий пожаоный.
if ((ADC1->CR & ADC_CR_ADEN) != 0) ADC1->CR |= ADC_CR_ADDIS;    // Если включен, выключить
while ((ADC1->CR & ADC_CR_ADEN) != 0) asm("nop");               // Дождаться
ADC1->CFGR1 &= ~ADC_CFGR1_DMAEN;                                // Выключить
// ADC_CR_ADEN - ADC enable control (Управление ADC включено)
// ADC_CR_ADDIS - ADC disable command (Команда отключения ADC)
// ADC_CFGR1_DMAEN - Direct memory access enable (Прямой доступ к памяти включен)

// Калибровка
ADC1->CR |= ADC_CR_ADCAL;                                       // Калибровка АЦП                                              
while ((ADC1->CR & ADC_CR_ADCAL) != 0) asm("nop");              // Дождаться
// ADC_CR_ADCAL - ADC calibration (Калибровка АЦП)

// Включение
ADC1->CR |= ADC_CR_ADEN;
while ((ADC1->ISR & ADC_ISR_ADRDY) == 0) asm("nop");  
// ADC_ISR_ADRDY - ADC Ready (Управление ADC включено)
// ADC_CR_ADEN - ADC enable control (Управление ADC включено)

/*
//______________________________________________________________________________
// Сторожевой таймер. Выше еще и обработчик прерываний, аналогичный кнопке "Стоп"
ADC1->CFGR1 |= ADC_CFGR1_AWDEN;         //  Включить сторожевой таймер во всей регулярной группе
ADC1->CFGR1 &= ~ADC_CFGR1_AWDSGL;       //  Включить сторожевой таймер по отдельному каналу

ADC1->TR = (vrefint_high << 16) + vrefint_low;          // 3686 = 4095-410 (от 2,97 до 0,33 В)
ADC1->IER |= ADC_IER_AWDIE;           //  Разрешить прерывания от сторожевого таймера
// Бит 27:16 HT [11: 0]: Высокий порог аналогового сторожевого таймера
// Бит 11: 0 LT [11: 0]: Нижний порог аналогового сторожевого таймера
//______________________________________________________________________________
*/

//ADC1->CFGR1 |= ADC_CFGR1_DISCEN;      // Прерывистый режим. Для запуска каждого преобразования, 
// определенного в последовательности, требуется событие запуска оборудования или программного обеспечения
//ADC1->CFGR1 |= ADC_CFGR1_AUTOFF;        // Автоматически отключать по окончании последовательности
//ADC1->CFGR1 |= ADC_CFGR1_WAIT;        // Преобразование режима ожидания. Новое преобразование может начаться
// только в том случае, если предыдущие данные были обработаны, как только регистр ADC_DR был прочитан или бит EOC был очищен
// Штука приятная и позиций кода и потребления энергии. Но какналов в последовательности может быть всего 3 (Три).

/*
//______________________________________________________________________________
// Может быть полезно разрешить преобразование одного или нескольких каналов ADC без чтения данных после каждого преобразования.
// В этом случае бит OVRMOD должен быть сконфигурирован в 1, а флаг OVR должен быть проигнорирован программным обеспечением.
// Когда OVRMOD = 1, событие переполнения не препятствует продолжению преобразования ADC, и регистр ADC_DR всегда содержит последние данные преобразования.
ADC1->CFGR1 |= ADC_CFGR1_OVRMOD;        // Обслуживаем только сторожевой таймер. Он работает до чтения данных.
// OVRMOD     0: Регистр ADC_DR сохраняется со старыми данными при обнаружении переполнения.
// OVRMOD     1: Регистр ADC_DR перезаписывается последним результатом преобразования при обнаружении переполнения.
//______________________________________________________________________________
*/

//  Включить АЦП в круговом режиме
ADC1->CFGR1 |= ADC_CFGR1_CONT;
//  ADC_CFGR1_DMAEN     Когда режим DMA включен, запрос DMA генерируется после преобразования каждого канала 
//  ADC_CFGR1_DMACFG    Кольцевой режим DMA (DMACFG = 1)
//  ADC_CFGR1_CONT      Непрерывное преобразование


//ADC1->CFGR2 &= ~ADC_CFGR2_CKMODE;     // Выберите HSI14, записав 00 в CKMODE (значение сброса)
// Источник тактирования                CKMODE[1:0]     Задержка между событием триггера
//                                                      и началом преобразования
// Выделенный 14 МГц тактовый сигнал            00      Задержка не является детерминированной (дребезг)
// PCLK, деленный на 2                          01      Задержка детерминирована (без дребезга)
// 							и равна 2.75 тактов ADC
// PCLK, деленный на 4				10	Задержка является детерминированной (без дребезга)
//                                                      и равна 2.625 тактам ADC


// Выбор регулярной группы
ADC1->CHSELR = ADC_CHSELR_CHSEL10 | ADC_CHSELR_CHSEL11 | ADC_CHSELR_CHSEL12 | ADC_CHSELR_CHSEL13;      // Выбрать каналы
//ADC1->CFGR1 ^= ADC_CFGR1_SCANDIR;    // изменить порядок опроса
// Порядок, в котором каналы будут сканироваться, можно настроить, запрограммировав бит бит SCANDIR в регистре ADC_CFGR1:
//      SCANDIR = 0: прямое сканирование. Канал 0 — канал 18
//      SCANDIR = 1: обратное сканирование. Канал 18 — канал 0
// Датчик температуры подключен к каналу ADC_IN16.
// Внутренний опорный сигнал напряжения VREFINT подключен к каналу ADC_IN17.
// Канал VBAT подключен к каналу ADC_IN18.
//ADC1->CHSELR = ADC_CHSELR_CHSEL18;// Выбрать VREFINT
// Как-то странно работает... в составе регулярной группы. Такое чувство, что его нужно опрашивать отдельно
ADC1->SMPR |= ADC_SMPR1_SMPR_0 | ADC_SMPR1_SMPR_2;      //  ADC_SMPR1_SMPR_0 | ADC_SMPR1_SMPR_1 | ADC_SMPR1_SMPR_2;
//      000:    1,5     тактов ADC
//      001:    7.5     ADC тактов
//      010:    13,5    тактов ADC
//      011:    28,5    тактовые циклы ADC
//      100:    41,5    тактов ADC
//      101:    55,5    тактов ADC
//      110:    71,5    тактов ADC
//      111:    239.5   Циклы синхронизации ADC
// Это время выборки должно быть достаточно для того, чтобы источник входного напряжения заряжал образец
// и удерживал конденсатор до уровня входного напряжения.
// С одним из 4 каналов в воздухе 55,5 тактов хватает

//ADC->CCR |= ADC_CCR_VREFEN; // Wake-up the VREFINT (only for VBAT, Temp sensor and VRefInt)
//Пробуждение VREFINT (только для VBAT, Temp sensor и VRefInt)
}
/*
/ Настройка DMA

//  Включить передачу DMA на АЦП и круговом режиме
//Примечание: бит DMAEN в регистре ADC_CFGR1 должен быть установлен после фазы калибровки ADC
//      В этом примере, взятом из мануала, не было написано кого сначала нужно настраивать.
//      Это привело к тому, что запись DMA1 начиналась не с первого, а с последнего датчика регулярной группы!!!
          
//DMA1_Channel1->CPAR = (uint32_t) (&(ADC1->DR));                 //  Настроить адрес регистра периферийных данных
//  В регистре SYSCFG прописано какой канал для какого устройства можно юзать см. Тав 29 мануала
//DMA1_Channel1->CMAR = (uint32_t)(&ADC1_Simpl[0]);                //  Настроить адрес памяти
//DMA1_Channel1->CNDTR = T_N_Simpl;               //  Настроить количество байт DMA-передачи, которое должно выполняться по каналу DMA 1
//  NDT [15: 0]: Количество передаваемых данных (от 0 до 65535). Этот регистр может быть записан только в том случае,
//  если канал отключен. Как только канал включен, этот регистр доступен только для чтения, указывая оставшиеся байты,
//  которые должны быть переданы. Этот регистр уменьшается после каждой передачи DMA
DMA1_Channel1->CCR |= DMA_CCR_MINC | DMA_CCR_MSIZE_1 | DMA_CCR_PSIZE_0;
//      Не совсем понятно, почему в примере из мануала стоял DMA_CCR_MSIZE_0
//      Если данные считываются в память - массив int [n], то они 32-х разрядные.
//DMA_CCR_MEM2MEM       Memory to memory mode                   Hежим памяти в память
//      0: режим памяти в память отключен
//      1: включен режим памяти в память
//DMA_CCR_PL            Bits(Channel Priority level             Уровень приоритета канала
//      00: Низкий
//      01: Средний
//      10: Высокий
//      11: Очень высокий
//DMA_CCR_MSIZE         MSIZE[1:0] bits (Memory size)           Размер памяти
//      00: 8 бит
//      01: 16 бит
//      10: 32 бит
//DMA_CCR_PSIZE         PSIZE[1:0] bits (Peripheral size)       Размер периферии
//      00: 8 бит
//      01: 16 бит
//      10: 32 бит
//DMA_CCR_MINC          Memory increment mode                   Инкрементный режим адреса памяти
//      0: Режим увеличения памяти отключен
//      1: включен режим увеличения памяти
//DMA_CCR_PINC          Peripheral increment mode               Инкрементный режим адреса периферии
//      0: отключен периферийный режим увеличения
//      1: включен режим расширенного периферийного устройства
//DMA_CCR_CIRC          Circular mode                           Циклический режим
//DMA_CCR_DIR           Data transfer direction                 Направление передачи данных
//      0: чтение с периферийных устройств
//      1: чтение из памяти
//DMA1_Channel1->CCR |= DMA_CCR_TEIE;                             //  Разрешение прерывания ошибки передачи
//      DMA_CCR_TEIE          Transfer error interrupt enable   Разрешение прерывания ошибки передачи
//      0: прерывание TE отключено
//      1: прерывание TE включено
//DMA1_Channel1->CCR |= DMA_CCR_HTIE;                             //  Разрешение прерывания с половинной передачей
//      DMA_CCR_HTIE    Half Transfer interrupt enable          Разрешение прерывания с половинной передачей
//DMA1_Channel1->CCR |= DMA_CCR_TCIE;                             //  Разрешение прерывания с полной передачей
//      DMA_CCR_TCIE    Transfer complete interrupt enable      Разрешение прерывания с полной передачей
//DMA1_Channel1->CCR |= DMA_CCR_EN;                               //  Включить канал DMA 1
//      DMA_CCR_EN      Channel enable                          Включить канал
//NVIC_EnableIRQ(DMA1_Channel1_IRQn);             // Разрешить прерывания DMA ADC
//NVIC->ISER[0] = (1 << ((DMA1_Channel1_IRQn) & 0x1F));
*/

